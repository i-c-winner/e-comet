# Задание: Группированная таблица статистики с AgGrid

## Контекст

Мы в сервисе используем AgGrid, хорошая библиотека для работы с таблицами во фронтенде.

## Описание задачи

Легенда задания такая, необходимо было реализовать группированную таблицу статистики, в которой уровни агрегации всегда **supplier → brand → type → article**, но твой коллега только начал и его вдруг сразила ужасная проказа, придется тебе доделывать.

### Формат данных

Статистика приходит с бэкенда в виде:

```typescript
interface IStatItemRaw {
    type: string; // тип
    article: string; // артикул
    brand: string; // бренд
    supplier: string; // поставщик
    cost: number[]; // цена в этот день за штуку
    orders: number[]; // заказы за день
    returns: number[]; // возвраты за день
    lastUpdate: string; // дата последнего обновления
}
```

массивы данных всегда за 30 дней.

## Требования

### 1. Расчет метрик и агрегация

- Часть метрик для дня должна рассчитываться на фронте (**revenue** как **cost \* buyouts** и **buyouts** как **orders - returns**)
- В таблице должны быть группировки, данные по уровням должны агрегироваться вверх
- Необходимо реализовать колонки суммы и среднего, которые должны рассчитаться на базе данных строки

### 2. Корректная обработка периодов

Периоды статистики в листах отличаются, заканчиваются на `lastUpdate` и идут по убыванию. Например, если сегодня `lastUpdate` 01.01.2026, то это первый элемент, для второго дата будет 31.12.2025 и т.д. Нужно корректно свести данные.

### 3. Локальное хранилище и производительность

- Статистика обновляется не часто, максимум раз в сутки, имеет смысл хранить ее локально у юзера и сохранять в IndexedDB (`AdStatsDatabase` осталась в наследство от твоего предшественника)
- Статистики может быть много (`getFull`), и нам нужно уметь ее всю агрегировать, не повесить страницу и не упасть
- Бэкенд у нас занятой во всех смыслах и там мы этого делать не можем, нужно что-то думать самим
- Наш больной коллега оставил нам идею реализации кастомной агрегации в воркере, через SSRM или через вычисление всех нод и TreeData

### 4. Качество кода и локализация

- Добавить i18n (опционально)
- Добавить темную тему (опционально)
- Поработать с чистотой типов/кода в статистике
- **Исправить текущий баг:** в группированной колонке не отображается артикул

## P.S.

Если потребуется StateManager то использовать эффектор, в довесок к нему можно patronum/rxjs.

Любые утилитарные либы по типу lodash, date-fns разрешены (ну только в пределах разумного, если оттуда будет единичный импорт без комментария, то проверяющий усомнится в целесообразности).

Чем чище - тем лучше, представь, что это имплементация в прод. Тесты не нужны. В результате ожидается ссылка на репозиторий, в котором будет pr\mr со всеми изменениями
